<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>透明的抽獎流程：公平、效率、體驗的最佳化 | Pitchat</title>
<meta name="keywords" content="">
<meta name="description" content="在社群平台舉辦抽獎活動時，許多參與者會關心抽獎是否公平。然而，由於 API 限制、處理流程不透明等因素，完全公平的抽獎在實務上很難達成。
Pitchat 採取不同的思路：與其追求難以達成的「絕對公平」，我們選擇透過「透明」來建立信任，實現「流程上的公平」。所有抽獎步驟都在你的瀏覽器中執行，過程即時可見；我們公開每個步驟的運作邏輯，讓你理解而非盲目相信。">
<meta name="author" content="Pitchat">
<link rel="canonical" href="http://localhost:1313/posts/how-pitchat-makes-lottery-transparent-/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a8501b4e1544bf104a4e2647be64df3637f95b6ac25a4298047d87fe0eacffa1.css" integrity="sha256-qFAbThVEvxBKTiZHvmTfNjf5W2rCWkKYBH2H/g6s/6E=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/how-pitchat-makes-lottery-transparent-/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Pitchat (Alt + H)">
                <img src="http://localhost:1313/pitchat.png" alt="" aria-label="logo"
                    height="30">Pitchat</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pitchat.co" title="首頁">
                    <span>首頁</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/" title="Pitchat">
                    <span>部落格</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      透明的抽獎流程：公平、效率、體驗的最佳化
    </h1>
    <div class="post-meta"><span title='2025-09-08 08:08:07 +0100 +0100'>九月 8, 2025</span>&nbsp;·&nbsp;Pitchat

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="http://localhost:1313/posts/how-pitchat-makes-lottery-transparent-/cover.png" alt="">
        
</figure>
  <div class="post-content"><p>在社群平台舉辦抽獎活動時，許多參與者會關心抽獎是否公平。然而，由於 API 限制、處理流程不透明等因素，完全公平的抽獎在實務上很難達成。</p>
<p>Pitchat 採取不同的思路：與其追求難以達成的「絕對公平」，我們選擇透過「透明」來建立信任，實現「流程上的公平」。所有抽獎步驟都在你的瀏覽器中執行，過程即時可見；我們公開每個步驟的運作邏輯，讓你理解而非盲目相信。</p>
<p>本文將詳細解說 Pitchat 的三階段抽獎流程：抽樣建立抽獎名單、條件篩選、隨機抽獎，以及我們如何在公平、效率、體驗間取得平衡。你將了解每個設計決策背後的理由，以及為什麼透明度比承諾更有價值。
a</p>
<h2 id="為什麼我們強調透明">為什麼我們強調「透明」？<a hidden class="anchor" aria-hidden="true" href="#為什麼我們強調透明">#</a></h2>
<p>當談到抽獎時，你的第一個反應會是什麼？可能會是「公平嗎」？這是合理的疑問。然而，實現「完全公平」的抽獎，在實務上面臨著許多難題。</p>
<h3 id="完全公平為何難以達成">完全公平為何難以達成？<a hidden class="anchor" aria-hidden="true" href="#完全公平為何難以達成">#</a></h3>
<p>理想的抽獎流程應該是這樣的：一次性獲取所有留言資料，篩選出符合資格的參與者，然後進行隨機抽獎。聽起來完美，但實踐中會遇到三大困難：</p>
<ol>
<li>
<p><strong>官方 API 的限制</strong></p>
<ul>
<li>社群平台的 API 存在一些限制，例如：呼叫頻率、分頁限制</li>
<li>無法一次獲取所有留言，需要逐頁讀取</li>
<li>整個過程隨著留言數越多越耗時越長</li>
</ul>
</li>
<li>
<p><strong>後端集中處理的問題</strong></p>
<ul>
<li>如果在伺服器上集中處理抽獎，過程對用戶不可見</li>
<li>用戶可能需要等待長時間才能看到結果</li>
<li>用戶無法驗證抽獎的公平性，只能信任平台</li>
</ul>
</li>
<li>
<p><strong>篩選條件實作的潛在遺漏</strong></p>
<ul>
<li>不同平台的 API 回傳格式不同</li>
<li>篩選邏輯的複雜性（關鍵字匹配、提及人數等）</li>
<li>邊界情況可能被忽略</li>
</ul>
</li>
</ol>
<p>這些因素都可能導致對「完全公平」的失準。因此，我們採取了不同的思路。</p>
<h3 id="我們的解決方案流程上的公平">我們的解決方案：「流程上的公平」<a hidden class="anchor" aria-hidden="true" href="#我們的解決方案流程上的公平">#</a></h3>
<p>與其追求無法完全達成的「絕對公平」，我們選擇在三個維度尋求最佳化：</p>
<table>
  <thead>
      <tr>
          <th>維度</th>
          <th>我們的做法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>公平</strong></td>
          <td>透過開放的流程和演算法，讓用戶可以驗證和理解</td>
      </tr>
      <tr>
          <td><strong>效率</strong></td>
          <td>採用聰明的抽樣策略處理大量留言</td>
      </tr>
      <tr>
          <td><strong>體驗</strong></td>
          <td>即時的進度反饋、清晰的篩選條件</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="我們如何實現透明">我們如何實現透明？<a hidden class="anchor" aria-hidden="true" href="#我們如何實現透明">#</a></h2>
<h3 id="透過以下方式實現完全透明">透過以下方式實現完全透明<a hidden class="anchor" aria-hidden="true" href="#透過以下方式實現完全透明">#</a></h3>
<p>我們透過以下來實現「透明」，讓你不需要盲目信任我們。</p>
<h4 id="方式一在瀏覽器中執行過程即時可見">方式一：在瀏覽器中執行，過程即時可見<a hidden class="anchor" aria-hidden="true" href="#方式一在瀏覽器中執行過程即時可見">#</a></h4>
<p><strong>所有抽獎步驟都在你的瀏覽器中執行</strong>。</p>
<p>這意味著什麼？</p>
<ul>
<li>整個抽獎過程不需要連接到我們的伺服器進行計算</li>
<li>你可以實時看到進度（「正在讀取留言」→「正在篩選」→「正在抽獎」）</li>
<li>如果懂技術的人願意，甚至可以打開瀏覽器開發者工具檢查程式碼邏輯</li>
<li>沒有「黑箱」，沒有隱藏的伺服器端操作</li>
</ul>
<p>這種方式需要犧牲一點什麼？速度。但我們通過巧妙的抽樣策略解決了這個問題。</p>
<h4 id="方式二公開說明實作邏輯">方式二：公開說明實作邏輯<a hidden class="anchor" aria-hidden="true" href="#方式二公開說明實作邏輯">#</a></h4>
<p>我們沒有只說「我們很公平」，而是詳細解釋「我們如何做到公平」。</p>
<p>你正在閱讀的這篇文章，就是我們對透明度承諾的第一步。我們在這裡：</p>
<ul>
<li>說明為什麼完全公平很難達成</li>
<li>解釋三個階段分別做什麼</li>
<li>列舉每個篩選條件的具體工作方式</li>
<li>展示我們在公平、效率、體驗之間如何取得平衡</li>
</ul>
<p>這讓非技術背景的使用者也能理解整個抽獎邏輯，而不是盲目信任。</p>
<hr>
<h2 id="抽獎流程三階段詳解以-instagram-為例">抽獎流程三階段詳解（以 Instagram 為例）<a hidden class="anchor" aria-hidden="true" href="#抽獎流程三階段詳解以-instagram-為例">#</a></h2>
<p>我們將抽獎過程分為三個清晰的階段。每個階段都有特定的目標和篩選條件。</p>
<h3 id="階段一邊讀取邊過濾並抽樣建立抽獎名單">階段一：邊讀取邊過濾並抽樣建立抽獎名單<a hidden class="anchor" aria-hidden="true" href="#階段一邊讀取邊過濾並抽樣建立抽獎名單">#</a></h3>
<p><strong>目標</strong>：從 Instagram API 讀取所有留言，同時應用第一層篩選和抽樣</p>
<h4 id="抽樣公平地處理大量留言">抽樣：公平地處理大量留言<a hidden class="anchor" aria-hidden="true" href="#抽樣公平地處理大量留言">#</a></h4>
<p>設想一下，當一則 Instagram 貼文有數十萬甚至數百萬留言時，除了無法直接一次讀取所有資料外，還會遇到兩個問題：</p>
<ul>
<li><strong>記憶體問題</strong>：無法在瀏覽器中同時保存百萬則留言</li>
<li><strong>處理時間</strong>：即使能保存，處理百萬筆資料也會花費很長時間</li>
</ul>
<p>我們的解決方案是採用 <strong>水塘抽樣（Reservoir Sampling）</strong> 演算法。</p>
<p><strong>它如何工作？</strong></p>
<p>簡單來說，我們邊讀取留言邊進行「公平抽樣」（注意：這裡的「留言」指的都是「有效留言」）：</p>
<ul>
<li>前 1,000 則有效留言：全部保留</li>
<li>第 1,001 則以後的有效留言：每則都有機率進入候選池，並可能替換掉現有的某一則留言</li>
</ul>
<p><strong>為什麼這樣是公平的？</strong></p>
<p>這個演算法經過數學證明，能保證一個關鍵特性：<strong>當處理完所有有效留言後，每一則有效留言最終被保留在候選池中的機率完全相等</strong>。</p>
<p>舉例來說：</p>
<ul>
<li>假設 API 回傳 50,000 則原始留言，經篩選後有 10,000 則有效留言</li>
<li>無論是第 1 則、第 5,000 則還是第 10,000 則有效留言，每一則最終留在候選池中的機率都是 1,000÷10,000 = 10%</li>
<li>另外 40,000 則被篩選掉的原始留言機率為 0%（完全不會中獎）</li>
</ul>
<p>如果有效留言總數是 100 萬則，每一則最終被保留的機率都是 1,000÷1,000,000 = 0.1%</p>
<p>這確保了不會因為留言時間先後而在<strong>有效留言之間</strong>產生任何偏差。</p>
<p><strong>為什麼適合這個場景？</strong></p>
<ol>
<li><strong>公平性</strong>：每則有效留言被選中的機率完全相等，不會因為時間先後而有差別</li>
<li><strong>記憶體效率</strong>：無論有多少留言，我們始終只在記憶體中保留約 1,000 則，節省資源</li>
<li><strong>可接受的速度</strong>：避免了百萬筆資料的處理時間，讓結果在合理時間內產生</li>
</ol>
<p>這是在「完美公平」（讀取所有留言）和「快速結果」（只抽少量樣本）之間的最佳平衡點。</p>
<p><strong>重要概念：什麼是「有效留言」？</strong></p>
<p>在進入詳細步驟前，先釐清一個重要概念：</p>
<ul>
<li><strong>原始留言</strong>：從 Instagram API 取得的所有留言</li>
<li><strong>有效留言</strong>：通過第一階段所有篩選條件（排除自己、重複留言、時間範圍）的留言</li>
</ul>
<p>例如，API 可能回傳 50,000 則原始留言，但經過第一階段篩選後，可能只有 10,000 則是「有效留言」。被篩選掉的 40,000 則留言（自己的、重複的、超出時間範圍的）完全不會進入後續的抽樣和中獎流程。</p>
<p><strong>這個區分為什麼重要？</strong> 因為後續的抽樣只在有效留言之間進行，確保每則有效留言都有相等的被選中機率。</p>
<p><strong>此階段涉及的操作</strong>：</p>
<ol>
<li>連續向 Instagram API 請求新一頁的留言</li>
<li>對每則留言應用即時篩選（下面會詳述）</li>
<li>對符合條件的留言進行公平抽樣</li>
<li>直到讀取完所有留言為止</li>
</ol>
<p><strong>本階段的三個篩選條件</strong>：</p>
<h4 id="排除自己">排除自己<a hidden class="anchor" aria-hidden="true" href="#排除自己">#</a></h4>
<ul>
<li><strong>用途</strong>：確保主辦方自己不會中獎</li>
<li><strong>工作方式</strong>：比較留言者的帳號與主辦方帳號</li>
<li><strong>為什麼重要</strong>：維持抽獎的公正性</li>
</ul>
<h4 id="重複留言">重複留言<a hidden class="anchor" aria-hidden="true" href="#重複留言">#</a></h4>
<ul>
<li><strong>用途</strong>：確保每個參與者只有一次中獎機會（基於第一則留言）</li>
<li><strong>工作方式</strong>：記住已經出現過的所有用戶名，只保留每個用戶的第一則留言</li>
<li><strong>為什麼重要</strong>：避免有人透過多次留言增加中獎機率</li>
</ul>
<h4 id="時間範圍">時間範圍<a hidden class="anchor" aria-hidden="true" href="#時間範圍">#</a></h4>
<ul>
<li><strong>用途</strong>：只考慮特定時間段內的留言</li>
<li><strong>工作方式</strong>：比較留言時間戳與設定的開始和結束時間</li>
<li><strong>為什麼重要</strong>：確保抽獎在公告期間內的參與被納入考量</li>
</ul>
<p><strong>進度恢復機制</strong>：
如果你在抽獎過程中關閉了瀏覽器，Pitchat 會記住進度，下次繼續時可以從中斷處恢復，不需要重新讀取所有留言。</p>
<hr>
<h3 id="階段二篩選條件過濾">階段二：篩選條件過濾<a hidden class="anchor" aria-hidden="true" href="#階段二篩選條件過濾">#</a></h3>
<p><strong>目標</strong>：在已讀取的留言基礎上，應用更複雜的篩選條件</p>
<p><strong>此階段涉及的操作</strong>：</p>
<ol>
<li>對階段一的候選留言逐一檢查</li>
<li>應用需要完整留言內容才能判斷的篩選條件</li>
<li>確認最終候選人數是否足以進行抽獎</li>
</ol>
<p><strong>本階段的四個篩選條件</strong>：</p>
<h4 id="封鎖名單">封鎖名單<a hidden class="anchor" aria-hidden="true" href="#封鎖名單">#</a></h4>
<ul>
<li><strong>用途</strong>：排除指定的用戶（例如，不符合參與資格的人）</li>
<li><strong>工作方式</strong>：如果留言者在封鎖名單中，則排除此留言</li>
<li><strong>例子</strong>：排除非本地使用者、排除品牌帳號</li>
</ul>
<h4 id="關鍵字">關鍵字<a hidden class="anchor" aria-hidden="true" href="#關鍵字">#</a></h4>
<ul>
<li><strong>用途</strong>：只納入包含特定關鍵字的留言</li>
<li><strong>工作方式</strong>：檢查留言文本是否包含指定的關鍵字</li>
<li><strong>兩種模式</strong>：
<ul>
<li><strong>「任一」模式</strong>：留言只需包含其中一個關鍵字即可（OR 邏輯）</li>
<li><strong>「全部」模式</strong>：留言必須包含所有指定的關鍵字（AND 邏輯）</li>
</ul>
</li>
<li><strong>例子</strong>：
<ul>
<li>關鍵字：「喜歡」、「推薦」（任一模式）→ 留言包含「喜歡」或「推薦」即可</li>
<li>關鍵字：「我喜歡」、「這個商品」（全部模式）→ 留言必須同時包含兩個詞語</li>
</ul>
</li>
</ul>
<h4 id="提及人數">提及人數<a hidden class="anchor" aria-hidden="true" href="#提及人數">#</a></h4>
<ul>
<li><strong>用途</strong>：確保參與者在留言中 @ 提及了足夠數量的人</li>
<li><strong>工作方式</strong>：計算留言中出現的 @mention 數量</li>
<li><strong>例子</strong>：設定「至少 2 個」→ 留言必須 @ 標記至少 2 個人</li>
</ul>
<h4 id="重複中獎">重複中獎<a hidden class="anchor" aria-hidden="true" href="#重複中獎">#</a></h4>
<ul>
<li><strong>用途</strong>：控制是否同一人可以中多個獎項</li>
<li><strong>工作方式</strong>：此設定影響第三階段的抽獎演算法（後面會詳述）</li>
<li><strong>兩種模式</strong>：
<ul>
<li><strong>允許</strong>：同一人可以中多個獎</li>
<li><strong>不允許</strong>：同一人最多只能中一個獎</li>
</ul>
</li>
</ul>
<p><strong>檢查候選人數</strong>：
在進入第三階段前，系統會確認是否有足夠的候選人來滿足獎項需求。例如，如果你要抽出 10 個獲獎者但只有 5 個符合條件的候選，系統會提醒你並拒絕抽獎。</p>
<hr>
<h3 id="階段三抽獎">階段三：抽獎<a hidden class="anchor" aria-hidden="true" href="#階段三抽獎">#</a></h3>
<p><strong>目標</strong>：從符合條件的候選人中隨機選出獲獎者</p>
<p><strong>此階段涉及的操作</strong>：</p>
<ol>
<li>根據「重複中獎」設定選擇合適的演算法</li>
<li>隨機選出指定數量的獲獎者</li>
<li>將結果展示給用戶</li>
</ol>
<p><strong>兩種抽獎方式</strong>：</p>
<h4 id="模式-a允許重複中獎">模式 A：允許重複中獎<a hidden class="anchor" aria-hidden="true" href="#模式-a允許重複中獎">#</a></h4>
<p><strong>當設定為「允許重複中獎」時</strong>：</p>
<p>工作方式很簡單：</p>
<ul>
<li>對於每一個要抽出的獎項，從候選人池中隨機選一個人</li>
<li>選出的人仍然留在池中，下一個獎項可能再選到他</li>
<li>簡單、快速</li>
</ul>
<p>使用情境：</p>
<ul>
<li>不在意某人中多次</li>
<li>想要最大化中獎機會給活躍參與者</li>
</ul>
<h4 id="模式-b不允許重複中獎">模式 B：不允許重複中獎<a hidden class="anchor" aria-hidden="true" href="#模式-b不允許重複中獎">#</a></h4>
<p><strong>當設定為「不允許重複中獎」時</strong>：</p>
<p>工作方式更複雜但更公平：</p>
<ol>
<li>先將所有候選人進行隨機排列（稱為「洗牌」）</li>
<li>依序從排列中選出第一個、第二個、第三個……獲獎者</li>
<li>每選出一個人，就標記他已中獎，之後不再考慮</li>
</ol>
<p>使用情境：</p>
<ul>
<li>獎品有限，要讓更多人有中獎機會</li>
</ul>
<hr>
<h2 id="為什麼採用這樣的設計">為什麼採用這樣的設計？<a hidden class="anchor" aria-hidden="true" href="#為什麼採用這樣的設計">#</a></h2>
<h3 id="1-在瀏覽器執行--透明且可驗證">1. 在瀏覽器執行 → 透明且可驗證<a hidden class="anchor" aria-hidden="true" href="#1-在瀏覽器執行--透明且可驗證">#</a></h3>
<ul>
<li><strong>透明</strong>：沒有伺服器端黑箱，用戶可以理解整個邏輯</li>
<li><strong>可驗證</strong>：技術人員可以審查程式碼，確保沒有暗箱操作</li>
<li><strong>即時反饋</strong>：用戶實時看到進度，而不是盲目等待</li>
</ul>
<h3 id="2-分三階段處理--效率最佳化">2. 分三階段處理 → 效率最佳化<a hidden class="anchor" aria-hidden="true" href="#2-分三階段處理--效率最佳化">#</a></h3>
<ul>
<li><strong>第一階段</strong>：同步「讀取」和「篩選」，減少需要保存的資料量</li>
<li><strong>第二階段</strong>：只對抽獎名單做條件篩選，減少計算</li>
<li><strong>第三階段</strong>：直接從最終候選人中抽獎，邏輯清晰</li>
</ul>
<p>這種分階段的方式讓系統既能處理大量資料，又保持高效率。</p>
<h3 id="3-抽樣機制--在公平與效率間取得平衡">3. 抽樣機制 → 在公平與效率間取得平衡<a hidden class="anchor" aria-hidden="true" href="#3-抽樣機制--在公平與效率間取得平衡">#</a></h3>
<p>水塘抽樣演算法確保：</p>
<ul>
<li>即使有百萬則留言，也只需保留 1,000 則</li>
<li>每則留言被選中的機率完全相等</li>
<li>處理速度從「數小時」減少到「數分鐘」或「數秒」</li>
</ul>
<h3 id="4-多層篩選--靈活滿足各種需求">4. 多層篩選 → 靈活滿足各種需求<a hidden class="anchor" aria-hidden="true" href="#4-多層篩選--靈活滿足各種需求">#</a></h3>
<p>七個不同的篩選條件可以組合使用：</p>
<ul>
<li>簡單抽獎：只開啟「排除自己」和「重複留言」</li>
<li>複雜抽獎：結合多個條件如「關鍵字」、「提及人數」、「時間範圍」</li>
<li>靈活性：不同類型的抽獎都能支援</li>
</ul>
<h3 id="5-快取機制--加速抽獎體驗">5. 快取機制 → 加速抽獎體驗<a hidden class="anchor" aria-hidden="true" href="#5-快取機制--加速抽獎體驗">#</a></h3>
<p>快取機制在以下情況下能避免重複工作：</p>
<p><strong>調整篩選或獎品設定時</strong>：當你只改變第二階段或第三階段的設定時，可以直接使用快取結果，無需重新讀取留言。</p>
<p><strong>應對斷線或意外中斷時</strong>：當遇到斷線、瀏覽器意外關閉等不可控情況時，系統會保留已完成的第一階段結果，讓你重新開啟時可以直接從篩選和抽獎階段繼續，避免重複讀取留言的時間成本。</p>
<p><strong>系統實現方式</strong>：系統會暫存第一階段的抽獎名單（有效期 30 分鐘）。如果改變貼文或第一階段設定（排除自己、重複留言、時間範圍），系統會重新抓取最新留言。</p>
<hr>
<h2 id="結語透明度的力量">結語：透明度的力量<a hidden class="anchor" aria-hidden="true" href="#結語透明度的力量">#</a></h2>
<p>在任何涉及隨機選擇的系統中，透明度都是建立信任的基礎。不是因為平台說「我們很公平」，而是因為用戶能夠理解和驗證整個過程。</p>
<p>我們對透明度的承諾體現在：</p>
<ul>
<li>不聲稱「絕對公平」，而是說明實現「流程上的公平」</li>
<li>展示完整的流程和邏輯，讓任何人都能理解</li>
<li>讓用戶實時看到發生了什麼，沒有隱藏的伺服器端黑箱</li>
</ul>
<p>我們相信 <strong>透明度比承諾更有價值</strong>。當你理解了整個流程的每一步——從 API 讀取、第一階段篩選、水塘抽樣、到最終的隨機抽獎——你不需要盲目相信我們。相反，你可以基於理解而自信地相信這個系統。</p>
<p>這就是 Pitchat 抽獎的核心理念。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://pitchat.co">2024 Pitchat</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
